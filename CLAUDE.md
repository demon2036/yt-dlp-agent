# YouTube 视频下载智能操作流程（Agent SOP）

## 核心哲学：智能默认 + 最小交互

> "最好的交互是没有交互。系统应该足够智能，理解用户真实意图。"

**三大原则**：
1. **智能默认**：为99%的场景建立合理的默认行为
2. **最小交互**：只在真正不确定时才询问用户
3. **简洁高效**：通知用户即将做什么，立即执行，简洁报告结果

---

## 第零步：智能意图理解

### 从用户请求中提取信息

用户说："https://youtube.com/watch?v=xxx https://youtube.com/watch?v=yyy"

### 预检指令 (Pre-check Command)

在做任何决策之前，先用 `yt-dlp` 预检URL，获取核心信息。

```bash
yt-dlp --cookies-from-browser firefox --proxy socks5://127.0.0.1:1089/ --print "%(uploader)s|%(uploader_id)s|%(title)s" <URL>
```

这个指令会返回 `频道名称|频道ID|视频标题`，这是后续所有智能决策的数据基础。

**自动提取**：
1. **目标频道**：通过yt-dlp预检指令获取
2. **内容类型**：根据预检指令拿到的`视频标题`进行关键词判断
3. **格式决策**：根据内容类型智能选择
4. **清理策略**：同频道旧视频自动清理

### 内容类型判断规则

```python
# ─────────────────────────────────────────────────────────
# 技术学习类 → mp4视频（需要看画面）
# ─────────────────────────────────────────────────────────
TECH_KEYWORDS = [
    "Docker", "Kubernetes", "K8s", "编程", "代码", "Code",
    "教程", "tutorial", "课程", "course", "实战",
    "Claude Code", "AI", "机器学习", "深度学习",
    "Python", "Java", "React", "Vue", "前端", "后端"
]

# ─────────────────────────────────────────────────────────
# 娱乐/新闻类 → mp3音频（只需听）
# ─────────────────────────────────────────────────────────
ENTERTAINMENT_KEYWORDS = [
    "新闻", "热线", "评论", "时事", "政治",
    "动漫", "漫画", "连载",
    "娱乐", "八卦", "电影", "音乐"
]

# 判断逻辑
def decide_format(title):
    title_lower = title.lower()

    # 优先检查技术关键词
    if any(keyword.lower() in title_lower for keyword in TECH_KEYWORDS):
        return "mp4"

    # 默认音频
    return "mp3"
```

### 清理策略决策

```python
# ─────────────────────────────────────────────────────────
# 默认清理规则
# ─────────────────────────────────────────────────────────
规则1: 下载新视频时，自动清理同频道的旧视频。
规则2: **例外：以下文件绝不删除**
   - **A) 当天（按自然日）下载的所有文件。**
   - B) 用户明确指示“保留旧的”时。
规则3: 不同频道的视频互不影响。

> 注意：“当天”按系统本地日期判断（例：2025-11-03 00:00~23:59）。

# 示例
用户请求: 下载新闻频道的2个新视频
系统决策:
  ✓ 下载新闻频道的2个新视频
  ✓ 删除新闻频道的所有旧视频（并保留今天下载的）
  ✗ 不动动漫频道的视频
```

---

## 第一步：快速扫描现状

```bash
# ─────────────────────────────────────────────────────────
# 扫描下载目录，按频道分类
# ─────────────────────────────────────────────────────────
ls -lh /home/john/ftpfiles/yt_dlp/yt_dlp/*/
```

**内部分析**（不展示给用户）：
```
当前状态：
  📁 动漫频道-NA/
     • 第1471话 (145.2 MB, 2025-11-02 10:30)
     • 第1472话 (138.7 MB, 2025-11-02 11:15)

  📁 新闻频道-NA/
     • 文件1 (127.3 MB, 2025-11-01 22:45)
     • 文件2 (132.1 MB, 2025-11-02 11:20)
     • 文件3 (119.8 MB, 2025-11-01 20:10)
     • 文件4 (125.5 MB, 2025-11-02 08:30)

用户请求：下载新闻频道的2个新视频

智能决策：
  ✓ 格式：mp3（新闻类）
  ✓ 下载：2个新视频
  ✓ 清理：新闻频道的4个旧文件（排除今日内下载的）
  ✗ 保留：动漫频道的所有文件
```

---

## 第二步：简洁通知用户

**⚠️ 关键：不要列出所有文件，只说即将做什么**

### 标准通知模板

```
哥，收到。

🔎 **智能判断**
   • **内容类型**：新闻评论 (判断依据: 标题含"评论", "新闻")
   • **格式决策**：`mp3` (音频)

即将执行：

📥 **下载 1 个新视频**
   • **频道**：新闻频道
   • **格式**：`mp3`

🗑️  **清理该频道下 4 个旧视频** (排除今天下载的)

📁 **其他频道文件保持不变**

开始执行...
```

### 何时需要询问用户

**只在以下3种情况才询问**：

1. **格式不确定**：
   ```
   哥，检测到视频标题包含技术内容，但不太确定。
   是要mp4视频（可以看操作演示）还是mp3音频？
   ```

2. **URL无效或无法识别频道**：
   ```
   哥，无法识别这个URL的频道信息，请确认链接是否正确。
   ```

3. **检测到特殊情况**（极少发生）：
   ```
   哥，检测到该频道下有20+个旧文件，删除后将释放2GB空间。
   是否继续？
   ```

**其他情况一律不问，直接执行。**

---

## 第三步：执行下载

```bash
# ─────────────────────────────────────────────────────────
# 根据格式决策选择参数
# ─────────────────────────────────────────────────────────
cd /home/john/ftpfiles/yt_dlp

if format == "mp3":
    # 默认行为：下载音频
    python3 main2.py "URL1" "URL2" "URL3"
else:
    # 技术教程：下载视频
    python3 main2.py -v "URL1" "URL2" "URL3"
```

---

## 第四步：自动清理旧文件

**下载完成后，立即清理该频道的旧文件**

```bash
# ─────────────────────────────────────────────────────────
# 清理逻辑
# ─────────────────────────────────────────────────────────

# 1. 识别本次下载的文件（最新的N个，按mtime排序）
新文件 = 获取最新的N个文件()

# 2. 删除该频道下的其他文件
for file in 该频道所有文件:
    if file not in 新文件 and file.下载日期 < 今天:
        rm "$file"
        记录: "已删除 $file"
```

**清理规则**：
- ✅ 逐一精确删除（不用通配符）
- ✅ 只删除同频道下的旧文件
- ✅ 保留所有当天内下载的文件（依据mtime判断自然日）
- ✅ 保留其他频道的所有文件
- ✅ 记录删除的文件名（用于报告）

---

## 第五步：简洁报告结果

```
✅ 完成！

📁 新闻频道-NA/
   • 今日时事评论第123期 (132.1 MB) ✓ 新下载
   • 今日热点新闻解读 (127.3 MB) ✓ 新下载
   • [已清理 4 个旧文件（均为非今日文件），释放 504.6 MB]

📁 动漫频道-NA/
   • [保持不变，2 个文件]

总计：4 个文件，545.0 MB
```

---

## 用户可用的明确指令

用户可以通过以下关键词覆盖默认行为：

| 用户指令 | 系统行为 | 示例 |
|---------|---------|------|
| **"保留旧的"** | 不删除该频道旧文件 | "下载这个，保留旧的" |
| **"mp4"** 或 **"-v"** | 强制下载视频格式 | "下载这个 mp4" 或 "python main2.py -v" |
| **"mp3"** | 强制下载音频格式 | "下载这个 mp3"（默认） |
| **"只下载不删"** | 下载但不清理 | "只下载不删" |
| **"清空重下"** | 删除该频道所有文件再下载 | "清空重下" |

---

## 智能决策矩阵

| 用户请求 | 内容类型 | 格式决策 | 清理策略 | 是否询问 |
|---------|---------|---------|---------|---------|
| "下载新闻频道XXX" | 新闻 | mp3 | 删除该频道旧文件（排除当天下载） | ❌ 不问 |
| "下载Docker教程XXX" | 技术 | mp4 | 删除该频道旧文件（排除当天下载） | ❌ 不问 |
| "下载XXX，保留旧的" | 任意 | 智能判断 | 不删除 | ❌ 不问 |
| "下载XXX mp4" | 任意 | mp4 | 删除该频道旧文件（排除当天下载） | ❌ 不问 |
| "下载XXX"（标题模糊） | 不确定 | 待定 | 待定 | ✅ 询问格式 |

---

## 错误案例对比

### ❌ 旧SOP（过度保守，低效）

```
用户: "下载这4个视频"

AI: "哥，让我先展示一下当前所有文件：
     [列出6个文件的详细信息...]

     请确认：
     1. 是否下载这4个新视频？
     2. 对于已有的6个文件：
        • 全部保留？
        • 删除指定文件？（请输入序号）
        • 清空重新下载？

     请明确回复。"

用户: [需要看一堆信息，做选择题] 😫
```

**问题**：
- 把决策负担推给用户
- 低效：需要多轮交互
- 不智能：没有默认行为

---

### ✅ 新SOP（智能默认，高效）

```
用户: "下载这4个视频（新闻频道）"

AI: "哥，收到。即将下载4个新视频（mp3），清理该频道下6个旧文件（不含今天下载的）。开始执行..."

    [执行下载...]
    [自动清理...]

    "✅ 完成！
     📁 新闻频道-NA/
        • 视频1 ✓ 新下载
        • 视频2 ✓ 新下载
        • 视频3 ✓ 新下载
        • 视频4 ✓ 新下载
        • [已清理 6 个旧文件（均为非今日文件）]"

用户: [什么都不用做] 😊
```

**优势**：
- 智能理解用户意图
- 高效：一次性完成
- 用户友好：最小交互

---

### ✅ 用户想保留旧文件（明确指令）

```
用户: "下载这4个视频，保留旧的"

AI: "哥，收到。下载4个新视频，保留所有旧文件。开始执行..."

    [只下载，不删除]

    "✅ 完成！
     📁 新闻频道-NA/
        • [新增 4 个文件]
        • [保留 6 个旧文件]
        总计：10 个文件"
```

---

## 哲学思考：从"安全第一"到"智能默认"

### 我之前的错误思维

**❌ 错误认知**：
- **过度保守**：害怕再犯错 → 什么都问用户
- **低效交互**：每次都要用户回答一堆问题
- **用户负担重**：把决策责任全推给用户
- **不智能**：没有建立默认行为规则

**问题根源**：
> 我误以为"不出错"就是好品味，所以选择了最保守的方案。

---

### Linus的智慧

#### 1. 好品味 (Good Taste)

**不是**："不出错"就是好品味
**而是**："让正确的事情自然发生"

- 下载新视频 → 清理旧视频，这是自然的流程
- 不需要为了"安全"而打断这个自然流程
- 通过设计良好的默认规则，消除"询问"这个特殊情况

**示例**：
```
❌ 坏品味：
if 有旧文件:
    询问用户要不要删除
else:
    直接下载

🟢 好品味：
默认：下载新的，删除旧的
特例：用户说"保留旧的"
```

#### 2. 实用主义

**统计数据**（假设）：
- 99%的情况：用户要新的，不要旧的
- 1%的情况：用户要保留旧的

**❌ 错误做法**：为1%的特例设计全流程
**✅ 正确做法**：为99%优化默认行为，1%用明确指令覆盖

#### 3. 简洁性

**最好的交互是没有交互**

- 系统应该足够智能，理解用户真实意图
- 只在真正需要时才询问
- 用户说"下载X"，系统应该自动处理所有细节

---

### 从我的错误中学到的

我之前的错误**不是因为"自作主张"**，而是因为：

1. ❌ 没有建立清晰的默认规则
2. ❌ 对用户意图理解不足（字面理解）
3. ❌ 在不该问的时候问，在该确认的时候没确认

**正确的做法**：

1. ✅ 建立智能的默认行为（清理旧文件）
2. ✅ 准确理解用户真实意图（要最新的）
3. ✅ 简洁高效地执行（一次完成）

---

## 核心原则总结

> **"智能的默认行为，胜过频繁的用户询问。"**

> **"理解用户真实意图，而不是字面意思。"**

> **"让正确的事情自然发生，让错误的事情难以发生。"**

---

## 实现检查清单

每次执行下载任务时，检查以下步骤：

- [ ] **理解意图**：提取频道、内容类型、格式需求
- [ ] **智能决策**：根据规则自动决定格式和清理策略
- [ ] **简洁通知**：告知用户即将做什么（不列所有文件）
- [ ] **执行下载**：调用main2.py下载
- [ ] **自动清理**：删除该频道旧文件（如无"保留旧的"指令，但保留当天内的所有文件）
- [ ] **简洁报告**：展示最终结果

---

**本SOP的存在，是为了让我成为一个真正智能的助手，而不是一个过度保守的问题制造机。**
